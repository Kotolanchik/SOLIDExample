# SOLID
## Принципы SOLID 
- это набор принципов проектирования, которые помогают создавать гибкие,
расширяемые и поддерживаемые программные системы. 

### Принцип единственной ответственности (Single Responsibility Principle - SRP):
#### Объяснение:
Каждый модуль или класс должен быть ответственен только за одну задачу.
Это позволяет легче понимать, изменять и тестировать код.
#### Пример:
Принцип единственной ответственности (Single Responsibility Principle - SRP) проявляется в данном коде, так как каждый класс (UserService, UserRepository, User) отвечает только за одну конкретную обязанность.

### Принцип открытости/закрытости (Open/Closed Principle - OCP):
#### Объяснение: 
Система должна быть открыта для расширения, но закрыта для изменения. 
Это означает, что новая функциональность должна добавляться путем расширения существующего кода, а не изменения его.
#### Пример:
Принцип открытости/закрытости проявляется в данном коде, так как функция CalcTotalArea расчета общей площади фигур работает с различными типами фигур через общий интерфейс Shape, не изменяя свою реализацию при добавлении новых типов фигур. 
Это позволяет расширять систему путем добавления новых типов фигур, не изменяя существующий код, и делает его закрытым для изменений, но открытым для расширения.

### Принцип подстановки Лисков (Liskov Substitution Principle - LSP):
#### Объяснение:
Объекты в программе должны быть заменяемыми своими подтипами без изменения свойств программы. 
Это означает, что подклассы должны быть взаимозаменяемыми суперклассами.
#### Пример:
Принцип подстановки Лисков (LSP) применяется в данном коде, потому что структуры Car и Motorcycle могут быть использованы вместо интерфейса Vehicle без изменения ожидаемого поведения программы.
Все операции, которые можно выполнить на объекте типа Vehicle, такие как Start, Stop, Accelerate и Brake, будут работать одинаково независимо от конкретного типа транспортного средства.

### Принцип разделения интерфейса (Interface Segregation Principle - ISP):
#### Объяснение:
Клиенты не должны зависеть от интерфейсов, которые они не используют.
Лучше создавать множество специализированных интерфейсов, чем один общий интерфейс.
#### Пример:
Используя интерфейсы Printer, Scanner и Fax, разделён общий интерфейс на более узкоспециализированные интерфейсы, 
соответствующие каждой отдельной функциональности.
 
### Принцип инверсии зависимостей (Dependency Inversion Principle - DIP):
#### Объяснение:
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. 
Оба типа модулей должны зависеть от абстракций. 
Абстракции не должны зависеть от деталей, а детали должны зависеть от абстракций.
#### Пример:
OrderService зависит от абстракции OrderRepository через интерфейс OrderRepository. 
Вместо того чтобы зависеть от конкретной реализации OrderRepository, OrderService взаимодействует только с абстракцией.
